# 游戏阶段系统重构计划

## 1. 当前问题分析

### 1.1 现有问题
- 阶段转换逻辑混乱，状态管理不清晰
- 白球状态重置不完整，导致第二次发射失败
- GameManager过于庞大，违反单一职责原则
- 玩家和敌人逻辑耦合在一起

### 1.2 根本原因
- 缺乏清晰的阶段管理架构
- 状态同步机制不完善
- 职责分离不明确

## 2. 目标架构设计

### 2.1 整体架构
```
GameManager (总协调器)
├── PlayerController (玩家阶段管理器)
│   ├── PlayerAimPhase (玩家蓄力阶段)
│   └── PlayerDashPhase (白球运动阶段)
├── MicroMovePhase (白球微调阶段) - 由GameManager直接管理
└── EnemyController (敌人阶段管理器)
    ├── EnemyAttackPhase (敌人攻击阶段)
    ├── EnemyMovePhase (敌人移动阶段)
    └── EnemyTelegraphPhase (敌人预攻击阶段)
```

### 2.2 阶段流程
```
玩家蓄力阶段 → 白球运动阶段 → 白球微调阶段 → 敌人攻击阶段 → 敌人移动阶段 → 敌人预攻击阶段 → 回到玩家蓄力阶段
```

## 3. 详细实现方案

### 3.1 核心组件设计

#### 3.1.1 GameManager (总协调器)
**职责：**
- 管理整体游戏流程
- 协调玩家和敌人阶段转换
- **直接管理微调阶段**（需要检查所有物体状态）
- 处理全局事件
- 管理UI状态

**核心方法：**
```csharp
public class GameManager : MonoBehaviour
{
    // 阶段管理
    public void StartPlayerPhase()
    public void StartEnemyPhase()
    public void StartMicroMovePhase() // 由GameManager直接管理
    
    // 全局状态检查
    public bool AllObjectsStopped()
    public bool AllWhiteBallsStopped()
    public bool AllEnemiesStopped()
    
    // 事件处理
    public void OnPlayerPhaseComplete()
    public void OnEnemyPhaseComplete()
    
    // 状态查询
    public bool IsPlayerPhase()
    public bool IsEnemyPhase()
}
```

#### 3.1.2 PlayerController (玩家阶段管理器)
**职责：**
- 管理玩家的两个阶段（蓄力、运动）
- 处理玩家输入
- 管理白球状态
- 协调阶段转换

**核心方法：**
```csharp
public class PlayerController : MonoBehaviour
{
    // 阶段管理
    public void StartAimPhase()
    public void StartDashPhase()
    
    // 状态查询
    public bool CanPlayerAct()
    public PlayerPhase GetCurrentPhase()
    
    // 事件
    public System.Action<PlayerPhase> OnPhaseChanged;
}
```

#### 3.1.3 EnemyController (敌人阶段管理器)
**职责：**
- 管理敌人的三个阶段
- 处理敌人行为
- 协调阶段转换

**核心方法：**
```csharp
public class EnemyController : MonoBehaviour
{
    // 阶段管理
    public void StartAttackPhase()
    public void StartMovePhase()
    public void StartTelegraphPhase()
    
    // 状态查询
    public EnemyPhase GetCurrentPhase()
    
    // 事件
    public System.Action<EnemyPhase> OnPhaseChanged;
}
```

### 3.2 阶段状态机设计

#### 3.2.1 玩家阶段枚举
```csharp
public enum PlayerPhase
{
    Aim,        // 蓄力阶段
    Dash        // 运动阶段
    // 微调阶段由GameManager直接管理
}
```

#### 3.2.2 敌人阶段枚举
```csharp
public enum EnemyPhase
{
    Attack,     // 攻击阶段
    Move,       // 移动阶段
    Telegraph   // 预攻击阶段
}
```

### 3.3 事件系统设计

#### 3.3.1 玩家事件
```csharp
public class PlayerEvents
{
    public System.Action OnAimComplete;      // 蓄力完成
    public System.Action OnDashComplete;     // 运动完成
    public System.Action OnMicroMoveComplete; // 微调完成
    public System.Action<PlayerPhase> OnPhaseChanged; // 阶段变化
}
```

#### 3.3.2 敌人事件
```csharp
public class EnemyEvents
{
    public System.Action OnAttackComplete;   // 攻击完成
    public System.Action OnMoveComplete;     // 移动完成
    public System.Action OnTelegraphComplete; // 预攻击完成
    public System.Action<EnemyPhase> OnPhaseChanged; // 阶段变化
}
```

### 3.4 微调阶段的特殊处理

#### 3.4.1 为什么微调阶段由GameManager管理？

微调阶段需要检查**所有白球和敌人都停止运动**才能开始，这超出了单个控制器的职责范围：

- **PlayerController** 只能管理自己的白球
- **EnemyController** 只能管理自己的敌人
- **需要全局协调者** 来检查所有物体的状态

#### 3.4.2 微调阶段实现细节

```csharp
public class GameManager : MonoBehaviour
{
    // 微调阶段管理
    private bool isMicroMoveActive = false;
    private float microMoveTimer = 0f;
    private const float MICRO_MOVE_DURATION = 3f;
    
    void HandleMicroMovePhase()
    {
        if (!isMicroMoveActive)
        {
            // 等待所有物体停止
            if (AllObjectsStopped())
            {
                StartMicroMove();
            }
        }
        else
        {
            // 微调阶段倒计时
            UpdateMicroMoveTimer();
        }
    }
    
    bool AllObjectsStopped()
    {
        // 检查所有白球
        var whiteBalls = FindObjectsOfType<WhiteBall>();
        foreach (var ball in whiteBalls)
        {
            if (ball.IsMoving()) return false;
        }
        
        // 检查所有敌人
        var enemies = FindObjectsOfType<Enemy>();
        foreach (var enemy in enemies)
        {
            if (enemy.IsMoving()) return false;
        }
        
        return true;
    }
    
    void StartMicroMove()
    {
        isMicroMoveActive = true;
        microMoveTimer = MICRO_MOVE_DURATION;
        Debug.Log("开始微调阶段，倒计时3秒");
    }
    
    void UpdateMicroMoveTimer()
    {
        microMoveTimer -= Time.deltaTime;
        if (microMoveTimer <= 0)
        {
            EndMicroMove();
        }
    }
    
    void EndMicroMove()
    {
        isMicroMoveActive = false;
        Debug.Log("微调阶段结束，进入敌人攻击阶段");
        // 切换到敌人攻击阶段
        currentState = GameState.EnemyTurn;
    }
}
```

### 3.5 状态同步机制

#### 3.5.1 白球状态管理
```csharp
public class WhiteBall : MonoBehaviour
{
    // 状态管理
    public void ResetForNewTurn()
    public void SetMoving(bool moving)
    public void SetInMicroMove(bool inMicroMove)
    
    // 状态查询
    public bool IsMoving()
    public bool IsInMicroMove()
    public bool CanLaunch()
}
```

#### 3.4.2 输入控制
```csharp
public class AimController : MonoBehaviour
{
    // 阶段检查
    public bool CanAim()
    public bool CanLaunch()
    
    // 输入处理
    public void HandleAimInput()
    public void HandleLaunchInput()
}
```

## 4. 实现步骤

### 4.1 第一阶段：重构GameManager
1. 简化GameManager，只保留总协调功能
2. 创建PlayerController和EnemyController
3. 实现基础的事件系统

### 4.2 第二阶段：实现玩家阶段管理
1. 创建PlayerController
2. 实现玩家的两个阶段（蓄力、运动）
3. 重构AimController和WhiteBall
4. 测试玩家阶段转换

### 4.3 第三阶段：实现微调阶段管理
1. 在GameManager中实现微调阶段逻辑
2. 实现AllObjectsStopped检查机制
3. 测试微调阶段转换

### 4.4 第四阶段：实现敌人阶段管理
1. 创建EnemyController
2. 实现敌人的三个阶段
3. 重构Enemy脚本
4. 测试敌人阶段转换

### 4.5 第五阶段：集成测试
1. 完整流程测试
2. 状态同步测试
3. 性能优化
4. 代码清理

## 5. 技术细节

### 5.1 状态重置策略
- 每个阶段开始时重置相关状态
- 阶段结束时清理临时状态
- 使用状态机模式确保状态一致性

### 5.2 事件通信机制
- 使用C#事件系统
- 避免直接引用，降低耦合
- 统一的事件命名规范

### 5.3 调试支持
- 每个阶段都有详细的日志输出
- 状态可视化工具
- 性能监控

## 6. 风险评估

### 6.1 技术风险
- 状态同步复杂性
- 事件系统性能影响
- 代码重构可能引入新bug

### 6.2 缓解措施
- 分阶段实现，逐步测试
- 保留原有代码作为备份
- 详细的单元测试

## 7. 预期收益

### 7.1 代码质量
- 职责分离清晰
- 代码可维护性提高
- 扩展性增强

### 7.2 开发效率
- 调试更容易
- 新功能开发更快
- 团队协作更顺畅

### 7.3 游戏体验
- 阶段转换更流畅
- 状态管理更可靠
- 性能更稳定

## 8. 总结

这个重构方案采用混合架构，既保持了集中控制的优势，又实现了模块化设计。通过清晰的职责分离和完善的事件系统，可以解决当前的状态管理问题，并为未来的功能扩展打下良好基础。

**关键设计决策：**
- **微调阶段由GameManager直接管理**：因为需要检查所有物体的停止状态，超出了单个控制器的职责范围
- **PlayerController只管理蓄力和运动阶段**：专注于玩家操作相关的逻辑
- **EnemyController管理敌人的三个阶段**：专注于敌人行为相关的逻辑
- **事件系统协调各组件**：确保松耦合和可扩展性

建议采用分阶段实现的方式，先重构核心组件，再逐步完善各个阶段，确保每个步骤都经过充分测试。
