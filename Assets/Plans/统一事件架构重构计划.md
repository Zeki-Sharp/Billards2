# 统一事件架构重构计划

## 当前问题分析

### 架构混乱的根本原因
1. **事件流不统一**：有些组件通过事件通信，有些通过直接调用
2. **职责重叠**：多个组件都在管理同一个功能
3. **控制流混乱**：不知道到底是谁在控制什么
4. **重复处理**：同一个功能被多个地方处理

### 具体问题表现
- EnemyPhaseController既触发事件又直接调用方法
- TelegraphManager既管理预告又调用具体敌人方法
- AttackRange既自己订阅事件又被其他组件调用
- 事件和直接调用混用，造成时序问题

## 重构目标

### 核心原则
1. **单一事件源**：只有EnemyPhaseController触发阶段事件
2. **职责分离**：每个组件只处理自己相关的阶段
3. **避免重复**：不重复调用相同功能
4. **清晰流程**：事件流向简单明确

### 预期效果
- 所有组件都响应同一个事件源
- 每个组件职责明确，不重叠
- 事件流向清晰，易于调试
- 易于扩展新功能

## 重构方案

### 第一阶段：清理现有架构

#### 1.1 确定事件源
- EnemyPhaseController作为唯一的事件源
- 只触发OnPhaseStart和OnPhaseComplete事件
- 不直接调用其他组件的方法

#### 1.2 重新定义组件职责
- **EnemyPhaseController**：只管理阶段切换和事件触发
- **Enemy**：只处理Attack和Move阶段的具体逻辑
- **AttackRange**：只处理攻击预告和攻击执行
- **TelegraphManager**：只管理预告时间，不调用具体敌人方法
- **EnemySpawner**：只处理Spawn阶段的具体逻辑

#### 1.3 统一事件响应模式
- 所有组件都订阅EnemyPhaseController的事件
- 根据阶段类型执行相应逻辑
- 完成后调用OnEnemyPhaseActionComplete通知

### 第二阶段：重构各组件

#### 2.1 AttackRange重构
- 订阅EnemyPhaseController.OnPhaseStart事件
- Telegraph阶段：显示预告，更新方向
- Attack阶段：隐藏预告
- 其他阶段：隐藏预告
- **注意**：AttackRange只负责展示，不执行攻击逻辑

#### 2.2 TelegraphManager重构
- **删除TelegraphManager**：没有存在的必要
- 攻击预告：AttackRange自己处理
- 生成预告：EnemySpawner自己处理
- 预告阶段：所有预告触发完就立即完成

#### 2.3 Enemy重构
- 只处理Attack和Move阶段
- Attack阶段：执行攻击逻辑，立即完成
- Move阶段：在Update中处理移动，完成后调用OnEnemyPhaseActionComplete
- **注意**：AttackRange只负责展示攻击范围，不执行攻击逻辑

#### 2.4 EnemySpawner重构
- 订阅EnemyPhaseController.OnPhaseStart事件
- Spawn阶段：执行生成逻辑，完成后调用OnEnemyPhaseActionComplete
- Telegraph阶段：显示生成预告，立即完成

### 第三阶段：优化和测试

#### 3.1 移除重复逻辑
- 删除整个TelegraphManager组件
- 删除EnemyPhaseController中直接调用其他组件方法的代码
- 统一所有组件的事件响应模式

#### 3.2 添加错误处理
- 确保所有组件都有适当的错误处理
- 添加超时机制防止系统卡死
- 添加调试信息便于问题追踪

#### 3.3 性能优化
- 避免不必要的FindObjectsOfType调用
- 优化事件订阅和取消订阅
- 减少重复计算

## 实施步骤

### 步骤1：创建新的AttackRange
- 基于事件驱动设计
- 只处理攻击范围展示逻辑
- 不执行攻击逻辑，不依赖其他组件的直接调用

### 步骤2：删除TelegraphManager
- 完全删除TelegraphManager组件
- 预告功能由各组件自己处理
- 预告阶段立即完成，不需要等待时间

### 步骤3：重构Enemy
- 简化阶段处理逻辑
- 只处理Attack和Move阶段
- 统一事件响应模式

### 步骤4：清理EnemyPhaseController
- 移除直接调用其他组件的代码
- 只保留事件触发功能
- 删除Telegraph阶段的特殊处理（由各组件自己处理）

### 步骤5：测试和验证
- 测试所有阶段切换是否正常
- 验证事件流向是否正确
- 检查是否有重复处理

## 预期收益

### 架构清晰度
- 事件流向简单明确
- 组件职责不重叠
- 易于理解和维护

### 开发效率
- 添加新功能只需要订阅事件
- 调试问题容易定位
- 代码修改影响范围小

### 系统稳定性
- 避免重复处理导致的bug
- 统一错误处理机制
- 更好的超时保护

## 风险评估

### 低风险
- 主要是重构现有功能，不改变核心逻辑
- 可以逐步实施，降低风险

### 中风险
- 需要仔细处理事件订阅和取消订阅
- 时序问题需要特别注意

### 缓解措施
- 分步骤实施，每步都测试
- 保留原有代码作为备份
- 添加详细的调试信息

## 总结

这个重构计划的核心是建立统一的事件驱动架构，让所有组件都响应同一个事件源，避免重复处理和职责混乱。通过清晰的职责分离和统一的事件响应模式，可以大大提高系统的可维护性和稳定性。
